package builtin

// DO NOT EDIT
// code generated by go:generate

import (
	"database/sql"
	"encoding/json"

	. "github.com/drone/drone/pkg/types"
)

var _ = json.Marshal

// generic database interface, matching both *sql.Db and *sql.Tx
type repoDB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

func getRepo(db repoDB, query string, args ...interface{}) (*Repo, error) {
	row := db.QueryRow(query, args...)
	return scanRepo(row)
}

func getRepos(db repoDB, query string, args ...interface{}) ([]*Repo, error) {
	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return scanRepos(rows)
}

func createRepo(db repoDB, query string, v *Repo) error {
	var v0 int64
	var v1 string
	var v2 string
	var v3 string
	var v4 string
	var v5 string
	var v6 bool
	var v7 string
	var v8 string
	var v9 string
	var v10 string
	var v11 int64
	var v12 bool
	var v13 bool
	var v14 bool
	var v15 string
	var v16 string
	var v17 int64
	var v18 int64
	var v19 []byte
	v0 = v.UserID
	v1 = v.Owner
	v2 = v.Name
	v3 = v.FullName
	v4 = v.Token
	v5 = v.Language
	v6 = v.Private
	v7 = v.Self
	v8 = v.Link
	v9 = v.Clone
	v10 = v.Branch
	v11 = v.Timeout
	v12 = v.Trusted
	v13 = v.PostCommit
	v14 = v.PullRequest
	v15 = v.PublicKey
	v16 = v.PrivateKey
	v17 = v.Created
	v18 = v.Updated
	v19, _ = json.Marshal(v.Params)

	res, err := db.Exec(query,
		&v0,
		&v1,
		&v2,
		&v3,
		&v4,
		&v5,
		&v6,
		&v7,
		&v8,
		&v9,
		&v10,
		&v11,
		&v12,
		&v13,
		&v14,
		&v15,
		&v16,
		&v17,
		&v18,
		&v19,
	)
	if err != nil {
		return err
	}

	v.ID, err = res.LastInsertId()
	return err
}

func updateRepo(db repoDB, query string, v *Repo) error {
	var v0 int64
	var v1 int64
	var v2 string
	var v3 string
	var v4 string
	var v5 string
	var v6 string
	var v7 bool
	var v8 string
	var v9 string
	var v10 string
	var v11 string
	var v12 int64
	var v13 bool
	var v14 bool
	var v15 bool
	var v16 string
	var v17 string
	var v18 int64
	var v19 int64
	var v20 []byte
	v0 = v.ID
	v1 = v.UserID
	v2 = v.Owner
	v3 = v.Name
	v4 = v.FullName
	v5 = v.Token
	v6 = v.Language
	v7 = v.Private
	v8 = v.Self
	v9 = v.Link
	v10 = v.Clone
	v11 = v.Branch
	v12 = v.Timeout
	v13 = v.Trusted
	v14 = v.PostCommit
	v15 = v.PullRequest
	v16 = v.PublicKey
	v17 = v.PrivateKey
	v18 = v.Created
	v19 = v.Updated
	v20, _ = json.Marshal(v.Params)

	_, err := db.Exec(query,
		&v1,
		&v2,
		&v3,
		&v4,
		&v5,
		&v6,
		&v7,
		&v8,
		&v9,
		&v10,
		&v11,
		&v12,
		&v13,
		&v14,
		&v15,
		&v16,
		&v17,
		&v18,
		&v19,
		&v20,
		&v0,
	)
	return err
}

func scanRepo(row *sql.Row) (*Repo, error) {
	var v0 int64
	var v1 int64
	var v2 string
	var v3 string
	var v4 string
	var v5 string
	var v6 string
	var v7 bool
	var v8 string
	var v9 string
	var v10 string
	var v11 string
	var v12 int64
	var v13 bool
	var v14 bool
	var v15 bool
	var v16 string
	var v17 string
	var v18 int64
	var v19 int64
	var v20 []byte

	err := row.Scan(
		&v0,
		&v1,
		&v2,
		&v3,
		&v4,
		&v5,
		&v6,
		&v7,
		&v8,
		&v9,
		&v10,
		&v11,
		&v12,
		&v13,
		&v14,
		&v15,
		&v16,
		&v17,
		&v18,
		&v19,
		&v20,
	)
	if err != nil {
		return nil, err
	}

	v := &Repo{}
	v.ID = v0
	v.UserID = v1
	v.Owner = v2
	v.Name = v3
	v.FullName = v4
	v.Token = v5
	v.Language = v6
	v.Private = v7
	v.Self = v8
	v.Link = v9
	v.Clone = v10
	v.Branch = v11
	v.Timeout = v12
	v.Trusted = v13
	v.PostCommit = v14
	v.PullRequest = v15
	v.PublicKey = v16
	v.PrivateKey = v17
	v.Created = v18
	v.Updated = v19
	json.Unmarshal(v20, &v.Params)

	return v, nil
}

func scanRepos(rows *sql.Rows) ([]*Repo, error) {
	var err error
	var vv []*Repo
	for rows.Next() {
		var v0 int64
		var v1 int64
		var v2 string
		var v3 string
		var v4 string
		var v5 string
		var v6 string
		var v7 bool
		var v8 string
		var v9 string
		var v10 string
		var v11 string
		var v12 int64
		var v13 bool
		var v14 bool
		var v15 bool
		var v16 string
		var v17 string
		var v18 int64
		var v19 int64
		var v20 []byte
		err = rows.Scan(
			&v0,
			&v1,
			&v2,
			&v3,
			&v4,
			&v5,
			&v6,
			&v7,
			&v8,
			&v9,
			&v10,
			&v11,
			&v12,
			&v13,
			&v14,
			&v15,
			&v16,
			&v17,
			&v18,
			&v19,
			&v20,
		)
		if err != nil {
			return vv, err
		}

		v := &Repo{}
		v.ID = v0
		v.UserID = v1
		v.Owner = v2
		v.Name = v3
		v.FullName = v4
		v.Token = v5
		v.Language = v6
		v.Private = v7
		v.Self = v8
		v.Link = v9
		v.Clone = v10
		v.Branch = v11
		v.Timeout = v12
		v.Trusted = v13
		v.PostCommit = v14
		v.PullRequest = v15
		v.PublicKey = v16
		v.PrivateKey = v17
		v.Created = v18
		v.Updated = v19
		json.Unmarshal(v20, &v.Params)
		vv = append(vv, v)
	}
	return vv, rows.Err()
}

const stmtRepoSelectList = `
SELECT
 repo_id
,repo_user_id
,repo_owner
,repo_name
,repo_full_name
,repo_token
,repo_language
,repo_private
,repo_self
,repo_link
,repo_clone
,repo_branch
,repo_timeout
,repo_trusted
,repo_post_commit
,repo_pull_request
,repo_public_key
,repo_private_key
,repo_created
,repo_updated
,repo_params
FROM repos
`

const stmtRepoSelectRange = `
SELECT
 repo_id
,repo_user_id
,repo_owner
,repo_name
,repo_full_name
,repo_token
,repo_language
,repo_private
,repo_self
,repo_link
,repo_clone
,repo_branch
,repo_timeout
,repo_trusted
,repo_post_commit
,repo_pull_request
,repo_public_key
,repo_private_key
,repo_created
,repo_updated
,repo_params
FROM repos
LIMIT ? OFFSET ?
`

const stmtRepoSelect = `
SELECT
 repo_id
,repo_user_id
,repo_owner
,repo_name
,repo_full_name
,repo_token
,repo_language
,repo_private
,repo_self
,repo_link
,repo_clone
,repo_branch
,repo_timeout
,repo_trusted
,repo_post_commit
,repo_pull_request
,repo_public_key
,repo_private_key
,repo_created
,repo_updated
,repo_params
FROM repos
WHERE repo_id = ?
`

const stmtRepoSelectRepoOwnerName = `
SELECT
 repo_id
,repo_user_id
,repo_owner
,repo_name
,repo_full_name
,repo_token
,repo_language
,repo_private
,repo_self
,repo_link
,repo_clone
,repo_branch
,repo_timeout
,repo_trusted
,repo_post_commit
,repo_pull_request
,repo_public_key
,repo_private_key
,repo_created
,repo_updated
,repo_params
FROM repos
WHERE repo_owner = ?
AND repo_name = ?
`

const stmtRepoSelectRepoFullName = `
SELECT
 repo_id
,repo_user_id
,repo_owner
,repo_name
,repo_full_name
,repo_token
,repo_language
,repo_private
,repo_self
,repo_link
,repo_clone
,repo_branch
,repo_timeout
,repo_trusted
,repo_post_commit
,repo_pull_request
,repo_public_key
,repo_private_key
,repo_created
,repo_updated
,repo_params
FROM repos
WHERE repo_full_name = ?
`

const stmtRepoInsert = `
INSERT INTO repos (
 repo_user_id
,repo_owner
,repo_name
,repo_full_name
,repo_token
,repo_language
,repo_private
,repo_self
,repo_link
,repo_clone
,repo_branch
,repo_timeout
,repo_trusted
,repo_post_commit
,repo_pull_request
,repo_public_key
,repo_private_key
,repo_created
,repo_updated
,repo_params
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);
`

const stmtRepoUpdate = `
UPDATE repos SET
 repo_user_id = ?
,repo_owner = ?
,repo_name = ?
,repo_full_name = ?
,repo_token = ?
,repo_language = ?
,repo_private = ?
,repo_self = ?
,repo_link = ?
,repo_clone = ?
,repo_branch = ?
,repo_timeout = ?
,repo_trusted = ?
,repo_post_commit = ?
,repo_pull_request = ?
,repo_public_key = ?
,repo_private_key = ?
,repo_created = ?
,repo_updated = ?
,repo_params = ?
WHERE repo_id = ?
`

const stmtRepoDelete = `
DELETE FROM repos
WHERE repo_id = ?
`

const stmtRepoTable = `
CREATE TABLE IF NOT EXISTS repos (
 repo_id		INTEGER PRIMARY KEY AUTOINCREMENT
,repo_user_id		INTEGER
,repo_owner		VARCHAR
,repo_name		VARCHAR
,repo_full_name		VARCHAR
,repo_token		VARCHAR
,repo_language		VARCHAR
,repo_private		BOOLEAN
,repo_self		VARCHAR
,repo_link		VARCHAR
,repo_clone		VARCHAR
,repo_branch		VARCHAR
,repo_timeout		INTEGER
,repo_trusted		BOOLEAN
,repo_post_commit	BOOLEAN
,repo_pull_request	BOOLEAN
,repo_public_key	VARCHAR
,repo_private_key	VARCHAR
,repo_created		INTEGER
,repo_updated		INTEGER
,repo_params		BLOB
);
`

const stmtRepoRepoOwnerNameIndex = `
CREATE UNIQUE INDEX IF NOT EXISTS ux_repo_owner_name ON repos (repo_owner,repo_name);
`

const stmtRepoRepoFullNameIndex = `
CREATE UNIQUE INDEX IF NOT EXISTS ux_repo_full_name ON repos (repo_full_name);
`
